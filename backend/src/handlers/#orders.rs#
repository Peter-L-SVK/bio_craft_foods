use axum::{Json, extract::{State, Path}, http::HeaderMap};
use serde_json::{json, Value};
use sqlx::MySqlPool;
use crate::models::order::Order;
use axum::http::StatusCode;
use validator::Validate;
use serde::{Deserialize, Serialize};



pub async fn list_orders(State(pool): State<MySqlPool>) -> (HeaderMap, Json<Value>) {
    let orders = sqlx::query_as::<_, Order>("SELECT * FROM orders")
        .fetch_all(&pool)
        .await
        .unwrap();

    let mut headers = HeaderMap::new();

    // Handle the case where there are no orders
    let content_range = if orders.is_empty() {
        "orders */0".to_string()
    } else {
        format!("orders 0-{}/{}", orders.len() - 1, orders.len())
    };

    headers.insert("Content-Range", content_range.parse().unwrap());

    (headers, Json(json!({
        "data": orders,
        "total": orders.len(),
    })))
}

pub async fn get_order(Path(id): Path<i32>, State(pool): State<MySqlPool>) -> Json<Value> {
    let order = sqlx::query_as::<_, Order>("SELECT * FROM orders WHERE id = ?")
        .bind(id)
        .fetch_one(&pool)
        .await
        .unwrap();

    Json(json!({ "data": order }))
}

#[derive(Serialize, Deserialize, Debug, Validate)]
pub struct CreateOrder {
    #[validate(range(min = 1, message = "Customer ID must be a positive number"))]
    pub customer_id: i32, // Use i32 for customer_id
    #[validate(range(min = 1, message = "Product ID must be a positive number"))]
    pub product_id: i32,  // Use i32 for product_id
    #[validate(range(min = 1, message = "Quantity must be a positive number"))]
    pub quantity: i32,
    #[validate(length(min = 1, message = "Order date is required"))]
    pub order_date: String,
}

pub async fn create_order(State(pool): State<MySqlPool>, Json(order): Json<CreateOrder>) -> Result<Json<Value>, StatusCode> {
    if let Err(_) = order.validate() {
        return Err(StatusCode::BAD_REQUEST);
    }

    let _ = sqlx::query("INSERT INTO orders (customer_id, product_id, quantity, order_date) VALUES (?, ?, ?, ?)")
        .bind(order.customer_id)
        .bind(order.product_id)
        .bind(order.quantity)
        .bind(&order.order_date)
        .execute(&pool)
        .await
        .unwrap();

    Ok(Json(json!({ "message": "Order created successfully" })))
}


pub async fn update_order(Path(id): Path<i32>, State(pool): State<MySqlPool>, Json(order): Json<CreateOrder>) -> Json<Value> {
    let _ = sqlx::query("UPDATE orders SET customer_id = ?, product_id = ?, quantity = ?, order_date = ? WHERE id = ?")
        .bind(order.customer_id)
        .bind(order.product_id)
        .bind(order.quantity)
        .bind(&order.order_date)
        .bind(id)
        .execute(&pool)
        .await
        .unwrap();

    Json(json!({ "message": "Order updated successfully" }))
}

pub async fn delete_order(Path(id): Path<i32>, State(pool): State<MySqlPool>) -> Json<Value> {
    let _ = sqlx::query("DELETE FROM orders WHERE id = ?")
        .bind(id)
        .execute(&pool)
        .await
        .unwrap();

    Json(json!({ "message": "Order deleted successfully" }))
}
